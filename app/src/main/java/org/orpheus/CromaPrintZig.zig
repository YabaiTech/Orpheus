const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;

pub const Float = f32;
pub const sample_rate = 11025;
pub const sample_rate_string = "11025";
pub const window_size = 4096;

// A Hamming window here likely reduces the ripple in the frequency domain generated by the FFT
// https://stackoverflow.com/questions/5418951/what-is-the-hamming-window-for
// Formula: w(i) = 0.54 - 0.46 * cos(2Ï€i / (N - 1))

// this is a comp-time directive
pub const hamming: [window_size]f32 = h: {
    @setEvalBranchQuota(window_size);
    var result: [window_size]f32 = undefined;
    for (&result, 0..) |*elem, i| {
        elem.* = 0.54 - 0.46 * @cos(2.0 * std.math.pi * @as(comptime_float, i) / (window_size - 1.0));
    }
    break :h result;
};

pub const Chroma = struct {
    buffer_len: u32,
    buffer_i: u32,
    buffer: [8][bands_len]Float = undefined,
    result_buffer: [bands_len]Float = undefined,

    pub const init: Chroma = .{
        .buffer_len = 1,
        .buffer_i = 0,
        .buffer = undefined,
    };

    const coefficients = [5]Float{ 0.25, 0.75, 1.0, 0.75, 0.25 };
    const bands_len = 12;
    const min_freq = 28;
    const max_freq = 3520;
    const min_index = @max(1, freqToIndex(min_freq));
    const max_index = @min(window_size / 2, freqToIndex(max_freq));

    // the following is a compile time directive
    const notes: [window_size]u8 = n: {
        @setEvalBranchQuota(window_size);
        var result = [1]u8{0} ** window_size;
        for (min_index..max_index) |i| {
            const freq = indexToFreq(i);
            const octave = freqToOctave(freq);
            const note = bands_len * (octave - @floor(octave));
            result[i] = @floor(note);
        }
        break :n result;
    };

    pub fn filter(cf: *Chroma, fft_frame: *const [1 + window_size / 2]Float) ?*const [bands_len]Float {
        {
            const buf = &cf.buffer[cf.buffer_i];
            @memset(buf, 0);
            for (notes[min_index..max_index], fft_frame[min_index..max_index]) |note, energy| {
                assert(!std.math.isNan(energy));
                assert(!std.math.isInf(buf[note]));
                assert(!std.math.isNan(buf[note]));
                buf[note] += energy;
                assert(!std.math.isInf(buf[note]));
                assert(!std.math.isNan(buf[note]));
            }
            cf.buffer_i = (cf.buffer_i + 1) % 8;
        }

        if (cf.buffer_len >= coefficients.len) {
            const offset = (cf.buffer_i + 8 - coefficients.len) % 8;
            @memset(&cf.result_buffer, 0);
            for (&cf.result_buffer, 0..) |*out, i| {
                for (coefficients, 0..) |coefficient, j| {
                    assert(!std.math.isInf(out.*));
                    assert(!std.math.isNan(out.*));
                    out.* += cf.buffer[(offset + j) % 8][i] * coefficient;
                    assert(!std.math.isInf(out.*));
                    assert(!std.math.isNan(out.*));
                }
            }
            normalize(&cf.result_buffer);
            return &cf.result_buffer;
        } else {
            cf.buffer_len += 1;
            return null;
        }
    }

    fn normalize(features: *[bands_len]Float) void {
        const norm = euclideanNorm(features);
        if (norm < 0.01) {
            @memset(features, 0);
        } else {
            for (features) |*feature| {
                feature.* /= norm;
            }
        }
    }

    fn euclideanNorm(features: *const [bands_len]Float) Float {
        var squares: Float = 0;
        for (features) |feature| {
            squares += feature * feature;
        }
        assert(!std.math.isInf(squares));
        return @sqrt(squares);
    }
};

fn freqToIndex(freq: comptime_float) comptime_int {
    return @round(window_size * freq / @as(comptime_float, sample_rate));
}

fn indexToFreq(i: comptime_float) comptime_float {
    return i * sample_rate / @as(comptime_float, window_size);
}

fn freqToOctave(freq: comptime_float) comptime_float {
    const base = 440.0 / 16.0;
    return @log2(freq / base);
}

const RollingIntegralImage = struct {
    const max_rows = 256 + 1;
    const num_columns = Chroma.bands_len;
    const data_size = max_rows * num_columns;

    data: [data_size]Float,
    num_rows: u32,

    pub const init: RollingIntegralImage = .{
        .data = [1]Float{0} ** data_size,
        .num_rows = 0,
    };

    pub fn addRow(rii: *RollingIntegralImage, features: *const [Chroma.bands_len]Float) void {
        const current_row = getRow(rii, rii.num_rows);
        {
            var accum: Float = 0;
            for (features, current_row) |feature, *out| {
                assert(!std.math.isNan(feature));
                accum += feature;
                out.* = accum;
            }
        }

        if (rii.num_rows > 0) {
            const last_row = getRow(rii, rii.num_rows - 1);
            for (last_row, current_row) |last, *cur| {
                cur.* += last;
            }
        }
        rii.num_rows += 1;
    }

    fn getRow(rii: *RollingIntegralImage, i: usize) *[num_columns]Float {
        return @constCast(getRowConst(rii, i));
    }

    fn getRowConst(rii: *const RollingIntegralImage, i: usize) *const [num_columns]Float {
        return rii.data[(i % max_rows) * num_columns ..][0..num_columns];
    }

    fn area(rii: *const RollingIntegralImage, r1: usize, c1: usize, r2: usize, c2: usize) Float {
        assert(r1 <= rii.num_rows);
        assert(r2 <= rii.num_rows);

        if (rii.num_rows > max_rows) {
            assert(r1 > rii.num_rows - max_rows);
            assert(r2 > rii.num_rows - max_rows);
        }

        assert(c1 <= num_columns);
        assert(c2 <= num_columns);

        if (r1 == r2 or c1 == c2) {
            return 0;
        }

        assert(r2 > r1);
        assert(c2 > c1);

        if (r1 == 0) {
            const row = getRowConst(rii, r2 - 1);
            if (c1 == 0) {
                return row[c2 - 1];
            } else {
                return row[c2 - 1] - row[c1 - 1];
            }
        } else {
            const row1 = getRowConst(rii, r1 - 1);
            const row2 = getRowConst(rii, r2 - 1);
            if (c1 == 0) {
                return row2[c2 - 1] - row1[c2 - 1];
            } else {
                return row2[c2 - 1] - row1[c2 - 1] - row2[c1 - 1] + row1[c1 - 1];
            }
        }
    }

    fn classify(rii: *const RollingIntegralImage, classifier: Classifier, offset: usize) u2 {
        const value = applyFilter(rii, classifier.filter, offset);
        return classifier.quantizer.quantize(value);
    }

    fn applyFilter(rii: *const RollingIntegralImage, filter: Filter, x: usize) Float {
        return switch (filter.type) {
            0 => filter0(rii, x, filter.y, filter.width, filter.height),
            1 => filter1(rii, x, filter.y, filter.width, filter.height),
            2 => filter2(rii, x, filter.y, filter.width, filter.height),
            3 => filter3(rii, x, filter.y, filter.width, filter.height),
            4 => filter4(rii, x, filter.y, filter.width, filter.height),
            5 => filter5(rii, x, filter.y, filter.width, filter.height),
            else => unreachable,
        };
    }

    fn filter0(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(w >= 1);
        assert(h >= 1);

        const a = rii.area(x, y, x + w, y + h);
        const b = 0;

        return subtractLog(a, b);
    }

    fn filter1(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(w >= 1);
        assert(h >= 1);

        const h_2 = h / 2;

        const a = rii.area(x, y + h_2, x + w, y + h);
        const b = rii.area(x, y, x + w, y + h_2);

        return subtractLog(a, b);
    }

    fn filter2(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(w >= 1);
        assert(h >= 1);

        const w_2 = w / 2;

        const a = rii.area(x + w_2, y, x + w, y + h);
        const b = rii.area(x, y, x + w_2, y + h);

        return subtractLog(a, b);
    }

    fn filter3(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(x >= 0);
        assert(y >= 0);
        assert(w >= 1);
        assert(h >= 1);

        const w_2 = w / 2;
        const h_2 = h / 2;

        const a = rii.area(x, y + h_2, x + w_2, y + h) + rii.area(x + w_2, y, x + w, y + h_2);
        const b = rii.area(x, y, x + w_2, y + h_2) + rii.area(x + w_2, y + h_2, x + w, y + h);

        return subtractLog(a, b);
    }

    fn filter4(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(w >= 1);
        assert(h >= 1);

        const h_3 = h / 3;

        const a = rii.area(x, y + h_3, x + w, y + 2 * h_3);
        const b = rii.area(x, y, x + w, y + h_3) + rii.area(x, y + 2 * h_3, x + w, y + h);

        return subtractLog(a, b);
    }

    fn filter5(rii: *const RollingIntegralImage, x: usize, y: usize, w: usize, h: usize) Float {
        assert(w >= 1);
        assert(h >= 1);

        const w_3 = w / 3;

        const a = rii.area(x + w_3, y, x + 2 * w_3, y + h);
        const b = rii.area(x, y, x + w_3, y + h) + rii.area(x + 2 * w_3, y, x + w, y + h);

        return subtractLog(a, b);
    }

    fn subtractLog(a: Float, b: Float) Float {
        const r = @log((1.0 + a) / (1.0 + b));
        assert(!std.math.isNan(r));
        return r;
    }
};

pub const FingerprintCalculator = struct {
    image: RollingIntegralImage,
    fingerprint: std.ArrayListUnmanaged(u32),
    allocator: Allocator,

    pub fn init(allocator: Allocator) FingerprintCalculator {
        return .{
            .image = RollingIntegralImage.init,
            .allocator = allocator,
            .fingerprint = .{},
        };
    }

    pub fn deinit(fc: *FingerprintCalculator) void {
        fc.fingerprint.deinit(fc.allocator);
        fc.* = undefined;
    }

    const classifiers = [16]Classifier{
        .{ .filter = Filter.init(0, 4, 3, 15), .quantizer = .{ .t = .{ 1.98215, 2.35817, 2.63523 } } },
        .{ .filter = Filter.init(4, 4, 6, 15), .quantizer = .{ .t = .{ -1.03809, -0.651211, -0.282167 } } },
        .{ .filter = Filter.init(1, 0, 4, 16), .quantizer = .{ .t = .{ -0.298702, 0.119262, 0.558497 } } },
        .{ .filter = Filter.init(3, 8, 2, 12), .quantizer = .{ .t = .{ -0.105439, 0.0153946, 0.135898 } } },

        .{ .filter = Filter.init(3, 4, 4, 8), .quantizer = .{ .t = .{ -0.142891, 0.0258736, 0.200632 } } },
        .{ .filter = Filter.init(4, 0, 3, 5), .quantizer = .{ .t = .{ -0.826319, -0.590612, -0.368214 } } },
        .{ .filter = Filter.init(1, 2, 2, 9), .quantizer = .{ .t = .{ -0.557409, -0.233035, 0.0534525 } } },
        .{ .filter = Filter.init(2, 7, 3, 4), .quantizer = .{ .t = .{ -0.0646826, 0.00620476, 0.0784847 } } },

        .{ .filter = Filter.init(2, 6, 2, 16), .quantizer = .{ .t = .{ -0.192387, -0.029699, 0.215855 } } },
        .{ .filter = Filter.init(2, 1, 3, 2), .quantizer = .{ .t = .{ -0.0397818, -0.00568076, 0.0292026 } } },
        .{ .filter = Filter.init(5, 10, 1, 15), .quantizer = .{ .t = .{ -0.53823, -0.369934, -0.190235 } } },
        .{ .filter = Filter.init(3, 6, 2, 10), .quantizer = .{ .t = .{ -0.124877, 0.0296483, 0.139239 } } },

        .{ .filter = Filter.init(2, 1, 1, 14), .quantizer = .{ .t = .{ -0.101475, 0.0225617, 0.231971 } } },
        .{ .filter = Filter.init(3, 5, 6, 4), .quantizer = .{ .t = .{ -0.0799915, -0.00729616, 0.063262 } } },
        .{ .filter = Filter.init(1, 9, 2, 12), .quantizer = .{ .t = .{ -0.272556, 0.019424, 0.302559 } } },
        .{ .filter = Filter.init(3, 4, 2, 14), .quantizer = .{ .t = .{ -0.164292, -0.0321188, 0.0846339 } } },
    };

    const max_filter_width = w: {
        var result: usize = 0;
        for (classifiers) |c| {
            result = @max(result, c.filter.width);
        }
        assert(result > 0);
        assert(result < 256);
        break :w result;
    };

    pub fn addFeatures(fc: *FingerprintCalculator, features: *const [Chroma.bands_len]Float) error{OutOfMemory}!void {
        fc.image.addRow(features);
        if (fc.image.num_rows >= max_filter_width) {
            const sub_fingerprint = calculateSubFingerprint(fc, fc.image.num_rows - max_filter_width);
            try fc.fingerprint.append(fc.allocator, sub_fingerprint);
        }
    }

    fn calculateSubFingerprint(fc: *FingerprintCalculator, offset: usize) u32 {
        const gray_codes = [_]u8{ 0, 1, 3, 2 };
        var bits: u32 = 0;
        for (classifiers) |c| {
            bits = (bits << 2) | gray_codes[fc.image.classify(c, offset)];
        }
        return bits;
    }
};

const Classifier = struct {
    filter: Filter,
    quantizer: Quantizer,
};

const Filter = struct {
    type: u8,
    y: u8,
    height: u8,
    width: u8,

    fn init(t: u8, y: u8, height: u8, width: u8) Filter {
        assert(t <= 5);
        return .{
            .type = t,
            .y = y,
            .height = height,
            .width = width,
        };
    }
};

const Quantizer = struct {
    t: [3]Float,

    fn quantize(q: Quantizer, value: Float) u2 {
        if (value < q.t[1]) {
            if (value < q.t[0]) {
                return 0;
            }
            return 1;
        } else {
            if (value < q.t[2]) {
                return 2;
            }
            return 3;
        }
    }
};

const Compress = struct {
    normal_bits: std.ArrayListUnmanaged(u8),
    exceptional_bits: std.ArrayListUnmanaged(u8),

    fn deinit(c: *Compress, gpa: Allocator) void {
        c.normal_bits.deinit(gpa);
        c.exceptional_bits.deinit(gpa);
        c.* = undefined;
    }

    fn processSubFingerprint(c: *Compress, gpa: Allocator, elem: u32) !void {
        const normal_bits = 3;
        const max_normal_value = (1 << normal_bits) - 1;

        var bit: u8 = 1;
        var last_bit: u8 = 0;
        var x = elem;
        while (x != 0) {
            if ((x & 1) != 0) {
                const value = bit - last_bit;
                if (value >= max_normal_value) {
                    try c.normal_bits.append(gpa, max_normal_value);
                    try c.exceptional_bits.append(gpa, value - max_normal_value);
                } else {
                    try c.normal_bits.append(gpa, value);
                }
                last_bit = bit;
            }
            x >>= 1;
            bit += 1;
        }
        try c.normal_bits.append(gpa, 0);
    }
};

pub fn compress(fingerprint: []const u32, gpa: Allocator) error{OutOfMemory}![]u8 {
    var c: Compress = .{
        .normal_bits = .{},
        .exceptional_bits = .{},
    };
    defer c.deinit(gpa);

    if (fingerprint.len > 0) {
        try c.normal_bits.ensureTotalCapacity(gpa, fingerprint.len);
        try c.exceptional_bits.ensureTotalCapacity(gpa, fingerprint.len / 10);
        try c.processSubFingerprint(gpa, fingerprint[0]);
        for (fingerprint[0 .. fingerprint.len - 1], fingerprint[1..]) |prev, cur|
            try c.processSubFingerprint(gpa, cur ^ prev);
    }

    const result = try gpa.alloc(u8, 4 +
        packedIntArraySize(3, c.normal_bits.items.len) +
        packedIntArraySize(5, c.exceptional_bits.items.len));
    errdefer gpa.free(result);

    const algorithm = 1;
    result[0] = algorithm;
    result[1] = @truncate(fingerprint.len >> 16);
    result[2] = @truncate(fingerprint.len >> 8);
    result[3] = @truncate(fingerprint.len);

    var ptr = result[4..].ptr;
    ptr = packInt3Array(ptr, c.normal_bits.items);
    ptr = packInt5Array(ptr, c.exceptional_bits.items);

    return result;
}

fn packedIntArraySize(n: usize, size: usize) usize {
    return (size * n + 7) / 8;  // due to operator precedence, it'll get multiplied before addition happens
}

// this function is simply packing the `source` array (which is a u8 array where each value is withing the [0-7] interval) to
// a compact array of u8 in `destination` where only the 3-bits required to store the values of `source` are stored side by side
fn packInt3Array(destination: [*]u8, source: []const u8) [*]u8 {
    var src = source;
    var dest = destination;
    sw: switch (src.len) {
        0 => return dest,
        1 => {
            dest[0] = (src[0] & 0x07);
            return dest[1..];
        },
        2 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3);
            return dest[1..];
        },
        3 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2);
            return dest[2..];
        },
        4 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2) | ((src[3] & 0x07) << 1);
            return dest[2..];
        },
        5 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2) | ((src[3] & 0x07) << 1) | ((src[4] & 0x07) << 4);
            return dest[2..];
        },
        6 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2) | ((src[3] & 0x07) << 1) | ((src[4] & 0x07) << 4) | ((src[5] & 0x01) << 7);
            dest[2] = ((src[5] & 0x06) >> 1);
            return dest[3..];
        },
        7 => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2) | ((src[3] & 0x07) << 1) | ((src[4] & 0x07) << 4) | ((src[5] & 0x01) << 7);
            dest[2] = ((src[5] & 0x06) >> 1) | ((src[6] & 0x07) << 2);
            return dest[3..];
        },
        else => {
            dest[0] = (src[0] & 0x07) | ((src[1] & 0x07) << 3) | ((src[2] & 0x03) << 6);
            dest[1] = ((src[2] & 0x04) >> 2) | ((src[3] & 0x07) << 1) | ((src[4] & 0x07) << 4) | ((src[5] & 0x01) << 7);
            dest[2] = ((src[5] & 0x06) >> 1) | ((src[6] & 0x07) << 2) | ((src[7] & 0x07) << 5);
            src = src[8..];
            dest = dest[3..];
            continue :sw src.len;
        },
    }
}

// similar to the `packInt3Array` array but for 5-bit values
fn packInt5Array(destination: [*]u8, source: []const u8) [*]u8 {
    var src = source;
    var dest = destination;
    sw: switch (src.len) {
        0 => return dest,
        1 => {
            dest[0] = (src[0] & 0x1f);
            return dest[1..];
        },
        2 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3);
            return dest[2..];
        },
        3 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2);
            return dest[2..];
        },
        4 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2) | ((src[3] & 0x01) << 7);
            dest[2] = ((src[3] & 0x1e) >> 1);
            return dest[3..];
        },
        5 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2) | ((src[3] & 0x01) << 7);
            dest[2] = ((src[3] & 0x1e) >> 1) | ((src[4] & 0x0f) << 4);
            dest[3] = ((src[4] & 0x10) >> 4);
            return dest[4..];
        },
        6 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2) | ((src[3] & 0x01) << 7);
            dest[2] = ((src[3] & 0x1e) >> 1) | ((src[4] & 0x0f) << 4);
            dest[3] = ((src[4] & 0x10) >> 4) | ((src[5] & 0x1f) << 1);
            return dest[4..];
        },
        7 => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2) | ((src[3] & 0x01) << 7);
            dest[2] = ((src[3] & 0x1e) >> 1) | ((src[4] & 0x0f) << 4);
            dest[3] = ((src[4] & 0x10) >> 4) | ((src[5] & 0x1f) << 1) | ((src[6] & 0x03) << 6);
            dest[4] = ((src[6] & 0x1c) >> 2);
            return dest[5..];
        },
        else => {
            dest[0] = (src[0] & 0x1f) | ((src[1] & 0x07) << 5);
            dest[1] = ((src[1] & 0x18) >> 3) | ((src[2] & 0x1f) << 2) | ((src[3] & 0x01) << 7);
            dest[2] = ((src[3] & 0x1e) >> 1) | ((src[4] & 0x0f) << 4);
            dest[3] = ((src[4] & 0x10) >> 4) | ((src[5] & 0x1f) << 1) | ((src[6] & 0x03) << 6);
            dest[4] = ((src[6] & 0x1c) >> 2) | ((src[7] & 0x1f) << 3);
            src = src[8..];
            dest = dest[5..];
            continue :sw src.len;
        },
    }
}
